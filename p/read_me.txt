Основной файл для запуска - main.py (>python main.py)
Настройки для количества архивов, файлов и путей для файлов - config.py
В router.py находится маршрутизатор выполнения задач, т.е. он решает какую задачу после какой выполнять
taskexecutor.py содержит методы параллельного выполнения задач
utils.py содержит полезные функции для выполнения задач
createtask.py содержит методы для выполнения 1 тестовой задачи
analyzertask.py содержит методы для выполнения 2 тестовой задачи


Код написан на python 2.7

Для параллелизма использована библиотека futures (https://pypi.python.org/pypi/futures)
Исходя из выводов умных статей - это наиболее быстрая и оптимизированная библиотека,
которая ладит с python GIL (Global Interpreter Lock - синхронизатор потоков).
К тому же концепция ThreadPool и Future, очень знакомые с Java,
подходит для параллельного выполнения множества однотипных задач,
а встроенный threads оптимальнее использовать для нескольких существенно отличающихся друг от друга задач.

Для первой задачи, при генерации файлов, было решено не использовать xml библиотеку,
что бы не загружать память и не снижать производительнось для таких небольших
и простых файлов ненужными скрытыми вычислениями в этой библиотеке.
Создание zip файлов выполняется парраллельно.

Для второй задачи использовались стандартные библиотеки xml и csv:
	xml вполне подходит для быстрого парсинга небольших и нехитрых по структуре файлов
	csv достаточно быстра и удобна для генерации статистики
Параллельно выполняются операции по распаковке zip архивов и, после завершения распаковки,
параллельно запускается парсинг xml файлов.
Сохранение в csv сделано без параллелизма, т.к. операция достаточно шустрая, даже для большого кол-ва xml,
и выполняется в разы быстрее чем распаковка и парсинг, хотя его тоже несложно за минуту распараллелить.


По затраченному времени:
	1 вечер (3-4 часа): чтение документации по параллелизму и написание TaskExecutor
	2 вечер (2-3 часа): написание функций для выполнения задач (createtask.py, analyzertask.py)
	3 вечер (3-4 часа): написание маршрутизатора, нагрузочное тестирование, рефакторинг

По трудностям:
	хотелось написать многоразовый TaskExecutor, но возникла проблема, что callback о завершении предыдущих
	задач выполнялся быстрее, чем закрытие пула, и следующие задачи могли наскочить на закрытый пул,
	ну а оставлять пул открытым нехорошо. Но если дольше подумать, то решения конечно же есть ;)

	хотелось сделать отображени хода выполнения задач в процентах, однако подсчитывание кол-во элементов в итераторе
	вызывает генерацию итерируемых объектов, что недопустимо для сохранения высокой производительности и потреблению памяти,
	можно было конечно заранее передавать кол-во объектов, но это не всегда возможно без затрат при считывании из базы, например.
